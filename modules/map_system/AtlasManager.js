/**
 * The World - Atlas Manager
 * @description Manages the content of the [TheWorld:Atlas] lorebook entry,
 * which provides the AI with a high-level, persistent overview of the entire known world map.
 */

export class AtlasManager {
    constructor({ logger, lorebookManager, mapDataManager }) {
        this.logger = logger;
        this.lorebookManager = lorebookManager;
        this.mapDataManager = mapDataManager;
        this.ATLAS_ENTRY_NAME = '[TheWorld:Atlas]';
    }

    async _getAtlasData() {
        const bookName = this.mapDataManager.bookName;
        if (!bookName) return { atlasText: '', backgroundImage: null };

        try {
            const worldbook = await this.lorebookManager.TavernHelper.getWorldbook(bookName);
            const atlasEntry = worldbook.find(e => e.name === this.ATLAS_ENTRY_NAME);
            if (!atlasEntry) return { atlasText: '', backgroundImage: null };

            // Handle backward compatibility for old plain text format
            try {
                const data = JSON.parse(atlasEntry.content);
                if (typeof data === 'object' && data !== null) {
                    return {
                        atlasText: data.atlasText || '',
                        backgroundImage: data.backgroundImage || null
                    };
                }
            } catch (e) {
                // It's likely the old plain text format
                return {
                    atlasText: atlasEntry.content,
                    backgroundImage: null
                };
            }
        } catch (error) {
            this.logger.error('[AtlasManager] Error getting Atlas data:', error);
            return { atlasText: '', backgroundImage: null };
        }
        return { atlasText: '', backgroundImage: null };
    }

    async getBackgroundImage() {
        const data = await this._getAtlasData();
        return data.backgroundImage;
    }

    async setBackgroundImage(imageUrl) {
        const bookName = this.mapDataManager.bookName;
        if (!bookName) return;

        const currentData = await this._getAtlasData();
        const newAtlasData = {
            atlasText: currentData.atlasText,
            backgroundImage: imageUrl || null
        };
        
        const contentString = JSON.stringify(newAtlasData, null, 2);
        const position = { type: 'before_character_definition', order: 0 };
        const comment = 'A high-level overview of the entire known world. Auto-generated by The World plugin. Do not edit manually.';

        await this.lorebookManager.createOrUpdateConstantEntry(bookName, this.ATLAS_ENTRY_NAME, contentString, position, comment);
        this.logger.log(`[AtlasManager] Background image updated to: ${imageUrl}`);
    }

    async updateAtlas() {
        this.logger.log(`[AtlasManager] Updating the world atlas entry...`);
        const bookName = this.mapDataManager.bookName;
        if (!bookName || !this.mapDataManager.isInitialized()) {
            this.logger.warn(`[AtlasManager] Cannot update atlas, map data not ready.`);
            if (bookName) {
                const worldbook = await this.lorebookManager.TavernHelper.getWorldbook(bookName);
                if (worldbook.some(e => e.name === this.ATLAS_ENTRY_NAME)) {
                    const currentData = await this._getAtlasData();
                    const emptyData = { ...currentData, atlasText: '[System Note: No map data loaded.]' };
                    const contentString = JSON.stringify(emptyData, null, 2);
                    const position = { type: 'before_character_definition', order: 0 };
                    const comment = 'A high-level overview of the entire known world. Auto-generated by The World plugin. Do not edit manually.';
                    await this.lorebookManager.createOrUpdateConstantEntry(bookName, this.ATLAS_ENTRY_NAME, contentString, position, comment);
                }
            }
            return;
        }

        // 1. Build the new atlas text content
        const newAtlasText = this._buildAtlasContent();
        
        // 2. Get current data to preserve other fields like backgroundImage
        const currentData = await this._getAtlasData();
        const newAtlasData = {
            ...currentData,
            atlasText: newAtlasText
        };

        // 3. Update the lorebook entry using the new robust method
        const contentString = JSON.stringify(newAtlasData, null, 2);
        const position = { type: 'before_character_definition', order: 0 };
        const comment = 'A high-level overview of the entire known world. Auto-generated by The World plugin. Do not edit manually.';
        
        await this.lorebookManager.createOrUpdateConstantEntry(bookName, this.ATLAS_ENTRY_NAME, contentString, position, comment);

        this.logger.success(`[AtlasManager] World atlas updated successfully.`);
    }

    /**
     * Calculates the relative direction of a child from its parent.
     * @param {string} parentCoords "x,y"
     * @param {string} childCoords "x,y"
     * @returns {string} Directional string (e.g., 'north-west').
     */
    _getRelativeDirection(parentCoords, childCoords) {
        const [px, py] = parentCoords.split(',').map(Number);
        const [cx, cy] = childCoords.split(',').map(Number);

        const dx = cx - px;
        const dy = cy - py; // Y is inverted in screen coordinates (down is positive)

        if (Math.abs(dx) < 5 && Math.abs(dy) < 5) {
            return 'within';
        }

        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        if (angle > -22.5 && angle <= 22.5) return 'east';
        if (angle > 22.5 && angle <= 67.5) return 'south-east';
        if (angle > 67.5 && angle <= 112.5) return 'south';
        if (angle > 112.5 && angle <= 157.5) return 'south-west';
        if (angle > 157.5 || angle <= -157.5) return 'west';
        if (angle > -157.5 && angle <= -112.5) return 'north-west';
        if (angle > -112.5 && angle <= -67.5) return 'north';
        if (angle > -67.5 && angle <= -22.5) return 'north-east';
        
        return 'unknown_direction';
    }


    _buildAtlasContent() {
        let content = `[System Note: This is a high-level atlas of the known world. Use the node IDs for commands.]\n\n`;
        
        const nodes = Array.from(this.mapDataManager.nodes.values());
        const nodeMap = new Map(nodes.map(node => [node.id, { ...node, children: [] }]));
        const roots = [];
        const unplotted = [];

        nodes.forEach(node => {
            if (node.parentId && nodeMap.has(node.parentId)) {
                nodeMap.get(node.parentId).children.push(nodeMap.get(node.id));
            } else {
                if (node.coords) {
                    roots.push(nodeMap.get(node.id));
                } else {
                    unplotted.push(nodeMap.get(node.id));
                }
            }
        });

        const buildNodeString = (node, depth) => {
            const prefix = '  '.repeat(depth) + '- ';
            const typeStr = node.type ? ` [${node.type}]` : '';
            const coordsStr = node.coords ? ` (${node.coords})` : '';
            let nodeString = `${prefix}${node.name} (${node.id})${typeStr}${coordsStr}\n`;

            if (node.children.length > 0) {
                const groupedChildren = {};
                node.children.forEach(child => {
                    let direction = 'unspecified_direction';
                    if (node.coords && child.coords) {
                        direction = this._getRelativeDirection(node.coords, child.coords);
                    }
                    if (!groupedChildren[direction]) {
                        groupedChildren[direction] = [];
                    }
                    groupedChildren[direction].push(child);
                });

                const sortedGroups = Object.keys(groupedChildren).sort();

                sortedGroups.forEach(groupName => {
                    const groupHeaderPrefix = '  '.repeat(depth + 1);
                    nodeString += `${groupHeaderPrefix}${groupName}:\n`;

                    groupedChildren[groupName].sort((a, b) => a.name.localeCompare(b.name));
                    groupedChildren[groupName].forEach(child => {
                        // Children are indented further under the group header
                        nodeString += buildNodeString(child, depth + 2);
                    });
                });
            }
            return nodeString;
        };
        
        roots.sort((a, b) => a.name.localeCompare(b.name));
        roots.forEach(root => {
            content += buildNodeString(root, 0);
        });

        if (unplotted.length > 0) {
            content += `\n== Uncharted Locations (No Coordinates) ==\n`;
            unplotted.sort((a, b) => a.name.localeCompare(b.name));
            unplotted.forEach(node => {
                // Unplotted items don't need directional grouping for their children
                 const prefix = '- ';
                 const typeStr = node.type ? ` [${node.type}]` : '';
                 content += `${prefix}${node.name} (${node.id})${typeStr}\n`;
            });
        }

        return content.trim();
    }
}